{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to osxmetadata","text":"<p>osxmetadata provides a simple interface to access various metadata about MacOS / OS X files.  Currently supported metadata attributes include tags/keywords, Finder comments, authors, etc.</p>"},{"location":"#reference","title":"Reference","text":"<p>Create an OSXMetaData object to access file metadata</p> Source code in <code>osxmetadata/osxmetadata.py</code> <pre><code>class OSXMetaData:\n    \"\"\"Create an OSXMetaData object to access file metadata\"\"\"\n\n    def __init__(self, fname: str):\n        \"\"\"Create an OSXMetaData object to access file metadata\n        fname: filename to operate on\n        \"\"\"\n        self._fname = pathlib.Path(fname)\n        if not self._fname.exists():\n            raise FileNotFoundError(f\"file does not exist: {fname}\")\n\n        self._posix_path = self._fname.resolve().as_posix()\n\n        # Create MDItemRef, NSURL, and xattr objects\n        # MDItemRef is used for most attributes\n        # NSURL and xattr are required for certain attributes like Finder tags\n        # Because many of the getter/setter functions require some combination of MDItemRef, NSURL, and xattr,\n        # they are created here and kept for the life of the object so that they don't have to be\n        # recreated for each attribute\n        # This does mean that if the file is moved or renamed, the object will still be pointing to the old file\n        # thus you should not rename or move a file while using an OSXMetaData object\n        self._mditem: CoreServices.MDItemRef = CoreServices.MDItemCreate(\n            None, self._posix_path\n        )\n        if not self._mditem:\n            raise OSError(f\"Unable to create MDItem for file: {fname}\")\n        self._url = NSURL.fileURLWithPath_(self._posix_path)\n        self._xattr = xattr.xattr(self._posix_path)\n\n        # Required so __setattr__ gets handled correctly during __init__\n        self.__init = True\n\n    def get(self, attribute: str) -&gt; MDItemValueType:\n        \"\"\"Get metadata attribute value\n        attribute: metadata attribute name\n        \"\"\"\n        return self.__getattr__(attribute)\n\n    def set(self, attribute: str, value: MDItemValueType):\n        \"\"\"Set metadata attribute value\n\n        Args:\n            attribute: metadata attribute name\n            value: value to set attribute to; must match the type expected by the attribute (e.g. str or list)\n        \"\"\"\n        self.__setattr__(attribute, value)\n\n    def get_xattr(\n        self, key: str, decode: t.Callable[[t.ByteString], t.Any] = None\n    ) -&gt; t.Any:\n        \"\"\"Get xattr value\n\n        Args:\n            key: xattr name\n            decode: optional Callable to decode value before returning\n        \"\"\"\n        xattr = self._xattr[key]\n        if decode:\n            xattr = decode(xattr)\n        return xattr\n\n    def set_xattr(\n        self, key: str, value: t.Any, encode: t.Callable[[t.ByteString], t.Any] = None\n    ):\n        \"\"\"Set xattr value\n\n        Args:\n            key: xattr name\n            encode: optional Callable to encode value before setting\n        \"\"\"\n        if encode:\n            value = encode(value)\n        self._xattr[key] = value\n\n    def remove_xattr(self, key: str):\n        \"\"\"Remove xattr\n\n        Args:\n            key: xattr name\n        \"\"\"\n        self._xattr.remove(key)\n\n    def asdict(self, attributes: t.Set[str] = ASDICT_ATTRIBUTES) -&gt; t.Dict[str, t.Any]:\n        \"\"\"Return all MDItem metadata (or a subset defined by attributes) as a dict\n\n        Args:\n            attributes: set of attributes to include in dict\n\n        Returns:\n            dict of metadata\n        \"\"\"\n        return {key: getattr(self, key) for key in attributes}\n\n    def to_json(\n        self, attributes: t.Set[str] = ASDICT_ATTRIBUTES, indent: int = 4\n    ) -&gt; str:\n        \"\"\"Return all MDItem metadata (or a subset defined by attributes) as a JSON string\n\n        Args:\n            attributes: set of attributes to include in JSON\n            indent: indent level for JSON output\n\n        Returns:\n            JSON string\n\n        Notes:\n            datetime objects are converted to ISO 8601 format\n            binary objects are converted to base64 encoded strings\n            the resulting JSON will include 3 additional keys: _version, _filepath, and _filename;\n            these are expected by the CLI backup/restore commands\n        \"\"\"\n\n        dict_data = self.asdict(attributes)\n\n        # add fields that backup/restore expects\n        dict_data.update(\n            {\n                \"_version\": __version__,\n                \"_filepath\": self._posix_path,\n                \"_filename\": self._fname.name,\n            }\n        )\n\n        for key, value in dict_data.items():\n            if isinstance(value, datetime.datetime):\n                dict_data[key] = value.isoformat()\n            elif isinstance(value, (list, tuple)):\n                if value and isinstance(value[0], datetime.datetime):\n                    dict_data[key] = [v.isoformat() for v in value]\n            elif isinstance(value, bytes):\n                dict_data[key] = base64.b64encode(value).decode(\"ascii\")\n\n        return json.dumps(dict_data, indent=indent)\n\n    def get_mditem_attribute_value(self, attribute: str) -&gt; t.Any:\n        \"\"\"Get the raw MDItem attribute value without any type conversion.\n\n        Args:\n            attribute: metadata attribute name\n\n        Returns:\n            raw MDItem attribute value as returned by CoreServices.MDItemCopyAttribute()\n\n        Note: This is a low level function that you probably don't need to use,\n        but may be useful in some cases. You should probably use the get() method instead.\n        \"\"\"\n        return CoreServices.MDItemCopyAttribute(self._mditem, attribute)\n\n    def set_mditem_attribute_value(self, attribute: str, value: t.Any) -&gt; bool:\n        \"\"\"Set the raw MDItem attribute value without any type conversion.\n\n        Args:\n            attribute: metadata attribute name\n            value: value to set attribute to\n\n        Returns: True if successful otherwise False\n\n        Note: This is a low level function that you probably don't need to use,\n        but may be useful in some cases. You should probably use the set() method instead.\n        \"\"\"\n        return MDItemSetAttribute(self._mditem, attribute, value)\n\n    @property\n    def path(self) -&gt; str:\n        \"\"\"Return path to file\"\"\"\n        return self._posix_path\n\n    def __getattr__(self, attribute: str) -&gt; MDItemValueType:\n        \"\"\"Get metadata attribute value\n\n        Args:\n            attribute: metadata attribute name\n        \"\"\"\n        if attribute in [\"tags\", _kMDItemUserTags]:\n            return get_finder_tags(self._xattr)\n        elif attribute in MDITEM_ATTRIBUTE_SHORT_NAMES:\n            # handle dynamic properties like self.keywords and self.comments\n            return get_mditem_metadata(\n                self._mditem, MDITEM_ATTRIBUTE_SHORT_NAMES[attribute]\n            )\n        elif (\n            attribute in MDITEM_ATTRIBUTE_DATA or attribute in MDIMPORTER_ATTRIBUTE_DATA\n        ):\n            return get_mditem_metadata(self._mditem, attribute)\n        elif attribute in NSURL_RESOURCE_KEY_DATA:\n            return get_nsurl_metadata(self._url, attribute)\n        elif attribute in [\"finderinfo\", _kFinderInfo]:\n            return get_finderinfo_bytes(self._xattr)\n        elif attribute == _kFinderStationeryPad:\n            return get_finderinfo_stationerypad(self._xattr)\n        elif attribute == _kFinderColor:\n            return get_finderinfo_color(self._xattr)\n        else:\n            raise AttributeError(f\"Invalid attribute: {attribute}\")\n\n    def __setattr__(self, attribute: str, value: t.Any):\n        \"\"\"set metadata attribute value\n\n        Args:\n            attribute: metadata attribute name\n            value: value to set\n        \"\"\"\n        try:\n            if not self.__init:\n                # during __init__ we don't want to call __setattr__ as it will\n                # cause an infinite loop\n                return super().__setattr__(attribute, value)\n            if attribute in [\"findercomment\", kMDItemFinderComment]:\n                # finder comment cannot be set using MDItemSetAttribute\n                set_or_remove_finder_comment(self._url, self._xattr, value)\n            elif attribute in [\"tags\", _kMDItemUserTags]:\n                # handle Finder tags\n                set_finder_tags(self._url, value)\n            elif attribute in MDITEM_ATTRIBUTE_SHORT_NAMES:\n                # handle dynamic properties like self.keywords and self.comments\n                attribute_name = MDITEM_ATTRIBUTE_SHORT_NAMES[attribute]\n                set_or_remove_mditem_metadata(self._mditem, attribute_name, value)\n            elif attribute in MDITEM_ATTRIBUTE_DATA:\n                set_or_remove_mditem_metadata(self._mditem, attribute, value)\n            elif attribute in NSURL_RESOURCE_KEY_DATA:\n                set_nsurl_metadata(self._url, attribute, value)\n            elif attribute in [\"finderinfo\", _kFinderInfo]:\n                set_finderinfo_bytes(self._xattr, value)\n            elif attribute == _kFinderStationeryPad:\n                set_finderinfo_stationerypad(self._xattr, bool(value))\n            elif attribute == _kFinderColor:\n                set_finderinfo_color(self._xattr, value)\n            elif attribute in ALL_ATTRIBUTES:\n                raise OSXMetaDataAttributeError(f\"Attribute {attribute} is read-only\")\n            else:\n                raise OSXMetaDataAttributeError(f\"Invalid attribute: {attribute}\")\n        except (KeyError, AttributeError):\n            super().__setattr__(attribute, value)\n        except OSXMetaDataAttributeError as e:\n            raise AttributeError(e) from e\n\n    def __getitem__(self, key: str) -&gt; MDItemValueType:\n        \"\"\"Get metadata attribute value\n\n        Args:\n            key: metadata attribute name\n        \"\"\"\n        if key == _kMDItemUserTags:\n            return get_finder_tags(self._xattr)\n        elif key in MDITEM_ATTRIBUTE_DATA:\n            return get_mditem_metadata(self._mditem, key)\n        elif key in NSURL_RESOURCE_KEY_DATA:\n            return get_nsurl_metadata(self._url, key)\n        else:\n            raise KeyError(f\"Invalid key: {key}\")\n\n    def __setitem__(self, key: str, value: t.Any):\n        \"\"\"set metadata attribute value\n\n        Args:\n            key: metadata attribute name\n            value: value to set\n        \"\"\"\n        if key == _kMDItemUserTags:\n            set_finder_tags(self._xattr, value)\n        elif key == kMDItemFinderComment:\n            set_or_remove_finder_comment(self._url, self._xattr, value)\n        elif key in MDITEM_ATTRIBUTE_DATA:\n            set_or_remove_mditem_metadata(self._mditem, key, value)\n        elif key in NSURL_RESOURCE_KEY_DATA:\n            set_nsurl_metadata(self._url, key, value)\n        elif key in ALL_ATTRIBUTES:\n            raise KeyError(f\"Attribute {key} is read-only\")\n        else:\n            raise KeyError(f\"Invalid key: {key}\")\n</code></pre>"},{"location":"#osxmetadata.osxmetadata.OSXMetaData.path","title":"<code>path: str</code>  <code>property</code>","text":"<p>Return path to file</p>"},{"location":"#osxmetadata.osxmetadata.OSXMetaData.__getattr__","title":"<code>__getattr__(attribute)</code>","text":"<p>Get metadata attribute value</p> <p>Parameters:</p> Name Type Description Default <code>attribute</code> <code>str</code> <p>metadata attribute name</p> required Source code in <code>osxmetadata/osxmetadata.py</code> <pre><code>def __getattr__(self, attribute: str) -&gt; MDItemValueType:\n    \"\"\"Get metadata attribute value\n\n    Args:\n        attribute: metadata attribute name\n    \"\"\"\n    if attribute in [\"tags\", _kMDItemUserTags]:\n        return get_finder_tags(self._xattr)\n    elif attribute in MDITEM_ATTRIBUTE_SHORT_NAMES:\n        # handle dynamic properties like self.keywords and self.comments\n        return get_mditem_metadata(\n            self._mditem, MDITEM_ATTRIBUTE_SHORT_NAMES[attribute]\n        )\n    elif (\n        attribute in MDITEM_ATTRIBUTE_DATA or attribute in MDIMPORTER_ATTRIBUTE_DATA\n    ):\n        return get_mditem_metadata(self._mditem, attribute)\n    elif attribute in NSURL_RESOURCE_KEY_DATA:\n        return get_nsurl_metadata(self._url, attribute)\n    elif attribute in [\"finderinfo\", _kFinderInfo]:\n        return get_finderinfo_bytes(self._xattr)\n    elif attribute == _kFinderStationeryPad:\n        return get_finderinfo_stationerypad(self._xattr)\n    elif attribute == _kFinderColor:\n        return get_finderinfo_color(self._xattr)\n    else:\n        raise AttributeError(f\"Invalid attribute: {attribute}\")\n</code></pre>"},{"location":"#osxmetadata.osxmetadata.OSXMetaData.__getitem__","title":"<code>__getitem__(key)</code>","text":"<p>Get metadata attribute value</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>metadata attribute name</p> required Source code in <code>osxmetadata/osxmetadata.py</code> <pre><code>def __getitem__(self, key: str) -&gt; MDItemValueType:\n    \"\"\"Get metadata attribute value\n\n    Args:\n        key: metadata attribute name\n    \"\"\"\n    if key == _kMDItemUserTags:\n        return get_finder_tags(self._xattr)\n    elif key in MDITEM_ATTRIBUTE_DATA:\n        return get_mditem_metadata(self._mditem, key)\n    elif key in NSURL_RESOURCE_KEY_DATA:\n        return get_nsurl_metadata(self._url, key)\n    else:\n        raise KeyError(f\"Invalid key: {key}\")\n</code></pre>"},{"location":"#osxmetadata.osxmetadata.OSXMetaData.__init__","title":"<code>__init__(fname)</code>","text":"<p>Create an OSXMetaData object to access file metadata fname: filename to operate on</p> Source code in <code>osxmetadata/osxmetadata.py</code> <pre><code>def __init__(self, fname: str):\n    \"\"\"Create an OSXMetaData object to access file metadata\n    fname: filename to operate on\n    \"\"\"\n    self._fname = pathlib.Path(fname)\n    if not self._fname.exists():\n        raise FileNotFoundError(f\"file does not exist: {fname}\")\n\n    self._posix_path = self._fname.resolve().as_posix()\n\n    # Create MDItemRef, NSURL, and xattr objects\n    # MDItemRef is used for most attributes\n    # NSURL and xattr are required for certain attributes like Finder tags\n    # Because many of the getter/setter functions require some combination of MDItemRef, NSURL, and xattr,\n    # they are created here and kept for the life of the object so that they don't have to be\n    # recreated for each attribute\n    # This does mean that if the file is moved or renamed, the object will still be pointing to the old file\n    # thus you should not rename or move a file while using an OSXMetaData object\n    self._mditem: CoreServices.MDItemRef = CoreServices.MDItemCreate(\n        None, self._posix_path\n    )\n    if not self._mditem:\n        raise OSError(f\"Unable to create MDItem for file: {fname}\")\n    self._url = NSURL.fileURLWithPath_(self._posix_path)\n    self._xattr = xattr.xattr(self._posix_path)\n\n    # Required so __setattr__ gets handled correctly during __init__\n    self.__init = True\n</code></pre>"},{"location":"#osxmetadata.osxmetadata.OSXMetaData.__setattr__","title":"<code>__setattr__(attribute, value)</code>","text":"<p>set metadata attribute value</p> <p>Parameters:</p> Name Type Description Default <code>attribute</code> <code>str</code> <p>metadata attribute name</p> required <code>value</code> <code>Any</code> <p>value to set</p> required Source code in <code>osxmetadata/osxmetadata.py</code> <pre><code>def __setattr__(self, attribute: str, value: t.Any):\n    \"\"\"set metadata attribute value\n\n    Args:\n        attribute: metadata attribute name\n        value: value to set\n    \"\"\"\n    try:\n        if not self.__init:\n            # during __init__ we don't want to call __setattr__ as it will\n            # cause an infinite loop\n            return super().__setattr__(attribute, value)\n        if attribute in [\"findercomment\", kMDItemFinderComment]:\n            # finder comment cannot be set using MDItemSetAttribute\n            set_or_remove_finder_comment(self._url, self._xattr, value)\n        elif attribute in [\"tags\", _kMDItemUserTags]:\n            # handle Finder tags\n            set_finder_tags(self._url, value)\n        elif attribute in MDITEM_ATTRIBUTE_SHORT_NAMES:\n            # handle dynamic properties like self.keywords and self.comments\n            attribute_name = MDITEM_ATTRIBUTE_SHORT_NAMES[attribute]\n            set_or_remove_mditem_metadata(self._mditem, attribute_name, value)\n        elif attribute in MDITEM_ATTRIBUTE_DATA:\n            set_or_remove_mditem_metadata(self._mditem, attribute, value)\n        elif attribute in NSURL_RESOURCE_KEY_DATA:\n            set_nsurl_metadata(self._url, attribute, value)\n        elif attribute in [\"finderinfo\", _kFinderInfo]:\n            set_finderinfo_bytes(self._xattr, value)\n        elif attribute == _kFinderStationeryPad:\n            set_finderinfo_stationerypad(self._xattr, bool(value))\n        elif attribute == _kFinderColor:\n            set_finderinfo_color(self._xattr, value)\n        elif attribute in ALL_ATTRIBUTES:\n            raise OSXMetaDataAttributeError(f\"Attribute {attribute} is read-only\")\n        else:\n            raise OSXMetaDataAttributeError(f\"Invalid attribute: {attribute}\")\n    except (KeyError, AttributeError):\n        super().__setattr__(attribute, value)\n    except OSXMetaDataAttributeError as e:\n        raise AttributeError(e) from e\n</code></pre>"},{"location":"#osxmetadata.osxmetadata.OSXMetaData.__setitem__","title":"<code>__setitem__(key, value)</code>","text":"<p>set metadata attribute value</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>metadata attribute name</p> required <code>value</code> <code>Any</code> <p>value to set</p> required Source code in <code>osxmetadata/osxmetadata.py</code> <pre><code>def __setitem__(self, key: str, value: t.Any):\n    \"\"\"set metadata attribute value\n\n    Args:\n        key: metadata attribute name\n        value: value to set\n    \"\"\"\n    if key == _kMDItemUserTags:\n        set_finder_tags(self._xattr, value)\n    elif key == kMDItemFinderComment:\n        set_or_remove_finder_comment(self._url, self._xattr, value)\n    elif key in MDITEM_ATTRIBUTE_DATA:\n        set_or_remove_mditem_metadata(self._mditem, key, value)\n    elif key in NSURL_RESOURCE_KEY_DATA:\n        set_nsurl_metadata(self._url, key, value)\n    elif key in ALL_ATTRIBUTES:\n        raise KeyError(f\"Attribute {key} is read-only\")\n    else:\n        raise KeyError(f\"Invalid key: {key}\")\n</code></pre>"},{"location":"#osxmetadata.osxmetadata.OSXMetaData.asdict","title":"<code>asdict(attributes=ASDICT_ATTRIBUTES)</code>","text":"<p>Return all MDItem metadata (or a subset defined by attributes) as a dict</p> <p>Parameters:</p> Name Type Description Default <code>attributes</code> <code>Set[str]</code> <p>set of attributes to include in dict</p> <code>ASDICT_ATTRIBUTES</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>dict of metadata</p> Source code in <code>osxmetadata/osxmetadata.py</code> <pre><code>def asdict(self, attributes: t.Set[str] = ASDICT_ATTRIBUTES) -&gt; t.Dict[str, t.Any]:\n    \"\"\"Return all MDItem metadata (or a subset defined by attributes) as a dict\n\n    Args:\n        attributes: set of attributes to include in dict\n\n    Returns:\n        dict of metadata\n    \"\"\"\n    return {key: getattr(self, key) for key in attributes}\n</code></pre>"},{"location":"#osxmetadata.osxmetadata.OSXMetaData.get","title":"<code>get(attribute)</code>","text":"<p>Get metadata attribute value attribute: metadata attribute name</p> Source code in <code>osxmetadata/osxmetadata.py</code> <pre><code>def get(self, attribute: str) -&gt; MDItemValueType:\n    \"\"\"Get metadata attribute value\n    attribute: metadata attribute name\n    \"\"\"\n    return self.__getattr__(attribute)\n</code></pre>"},{"location":"#osxmetadata.osxmetadata.OSXMetaData.get_mditem_attribute_value","title":"<code>get_mditem_attribute_value(attribute)</code>","text":"<p>Get the raw MDItem attribute value without any type conversion.</p> <p>Parameters:</p> Name Type Description Default <code>attribute</code> <code>str</code> <p>metadata attribute name</p> required <p>Returns:</p> Type Description <code>Any</code> <p>raw MDItem attribute value as returned by CoreServices.MDItemCopyAttribute()</p> <p>Note: This is a low level function that you probably don't need to use, but may be useful in some cases. You should probably use the get() method instead.</p> Source code in <code>osxmetadata/osxmetadata.py</code> <pre><code>def get_mditem_attribute_value(self, attribute: str) -&gt; t.Any:\n    \"\"\"Get the raw MDItem attribute value without any type conversion.\n\n    Args:\n        attribute: metadata attribute name\n\n    Returns:\n        raw MDItem attribute value as returned by CoreServices.MDItemCopyAttribute()\n\n    Note: This is a low level function that you probably don't need to use,\n    but may be useful in some cases. You should probably use the get() method instead.\n    \"\"\"\n    return CoreServices.MDItemCopyAttribute(self._mditem, attribute)\n</code></pre>"},{"location":"#osxmetadata.osxmetadata.OSXMetaData.get_xattr","title":"<code>get_xattr(key, decode=None)</code>","text":"<p>Get xattr value</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>xattr name</p> required <code>decode</code> <code>Callable[[ByteString], Any]</code> <p>optional Callable to decode value before returning</p> <code>None</code> Source code in <code>osxmetadata/osxmetadata.py</code> <pre><code>def get_xattr(\n    self, key: str, decode: t.Callable[[t.ByteString], t.Any] = None\n) -&gt; t.Any:\n    \"\"\"Get xattr value\n\n    Args:\n        key: xattr name\n        decode: optional Callable to decode value before returning\n    \"\"\"\n    xattr = self._xattr[key]\n    if decode:\n        xattr = decode(xattr)\n    return xattr\n</code></pre>"},{"location":"#osxmetadata.osxmetadata.OSXMetaData.remove_xattr","title":"<code>remove_xattr(key)</code>","text":"<p>Remove xattr</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>xattr name</p> required Source code in <code>osxmetadata/osxmetadata.py</code> <pre><code>def remove_xattr(self, key: str):\n    \"\"\"Remove xattr\n\n    Args:\n        key: xattr name\n    \"\"\"\n    self._xattr.remove(key)\n</code></pre>"},{"location":"#osxmetadata.osxmetadata.OSXMetaData.set","title":"<code>set(attribute, value)</code>","text":"<p>Set metadata attribute value</p> <p>Parameters:</p> Name Type Description Default <code>attribute</code> <code>str</code> <p>metadata attribute name</p> required <code>value</code> <code>MDItemValueType</code> <p>value to set attribute to; must match the type expected by the attribute (e.g. str or list)</p> required Source code in <code>osxmetadata/osxmetadata.py</code> <pre><code>def set(self, attribute: str, value: MDItemValueType):\n    \"\"\"Set metadata attribute value\n\n    Args:\n        attribute: metadata attribute name\n        value: value to set attribute to; must match the type expected by the attribute (e.g. str or list)\n    \"\"\"\n    self.__setattr__(attribute, value)\n</code></pre>"},{"location":"#osxmetadata.osxmetadata.OSXMetaData.set_mditem_attribute_value","title":"<code>set_mditem_attribute_value(attribute, value)</code>","text":"<p>Set the raw MDItem attribute value without any type conversion.</p> <p>Parameters:</p> Name Type Description Default <code>attribute</code> <code>str</code> <p>metadata attribute name</p> required <code>value</code> <code>Any</code> <p>value to set attribute to</p> required <p>Returns: True if successful otherwise False</p> <p>Note: This is a low level function that you probably don't need to use, but may be useful in some cases. You should probably use the set() method instead.</p> Source code in <code>osxmetadata/osxmetadata.py</code> <pre><code>def set_mditem_attribute_value(self, attribute: str, value: t.Any) -&gt; bool:\n    \"\"\"Set the raw MDItem attribute value without any type conversion.\n\n    Args:\n        attribute: metadata attribute name\n        value: value to set attribute to\n\n    Returns: True if successful otherwise False\n\n    Note: This is a low level function that you probably don't need to use,\n    but may be useful in some cases. You should probably use the set() method instead.\n    \"\"\"\n    return MDItemSetAttribute(self._mditem, attribute, value)\n</code></pre>"},{"location":"#osxmetadata.osxmetadata.OSXMetaData.set_xattr","title":"<code>set_xattr(key, value, encode=None)</code>","text":"<p>Set xattr value</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>xattr name</p> required <code>encode</code> <code>Callable[[ByteString], Any]</code> <p>optional Callable to encode value before setting</p> <code>None</code> Source code in <code>osxmetadata/osxmetadata.py</code> <pre><code>def set_xattr(\n    self, key: str, value: t.Any, encode: t.Callable[[t.ByteString], t.Any] = None\n):\n    \"\"\"Set xattr value\n\n    Args:\n        key: xattr name\n        encode: optional Callable to encode value before setting\n    \"\"\"\n    if encode:\n        value = encode(value)\n    self._xattr[key] = value\n</code></pre>"},{"location":"#osxmetadata.osxmetadata.OSXMetaData.to_json","title":"<code>to_json(attributes=ASDICT_ATTRIBUTES, indent=4)</code>","text":"<p>Return all MDItem metadata (or a subset defined by attributes) as a JSON string</p> <p>Parameters:</p> Name Type Description Default <code>attributes</code> <code>Set[str]</code> <p>set of attributes to include in JSON</p> <code>ASDICT_ATTRIBUTES</code> <code>indent</code> <code>int</code> <p>indent level for JSON output</p> <code>4</code> <p>Returns:</p> Type Description <code>str</code> <p>JSON string</p> Notes <p>datetime objects are converted to ISO 8601 format binary objects are converted to base64 encoded strings the resulting JSON will include 3 additional keys: _version, _filepath, and _filename; these are expected by the CLI backup/restore commands</p> Source code in <code>osxmetadata/osxmetadata.py</code> <pre><code>def to_json(\n    self, attributes: t.Set[str] = ASDICT_ATTRIBUTES, indent: int = 4\n) -&gt; str:\n    \"\"\"Return all MDItem metadata (or a subset defined by attributes) as a JSON string\n\n    Args:\n        attributes: set of attributes to include in JSON\n        indent: indent level for JSON output\n\n    Returns:\n        JSON string\n\n    Notes:\n        datetime objects are converted to ISO 8601 format\n        binary objects are converted to base64 encoded strings\n        the resulting JSON will include 3 additional keys: _version, _filepath, and _filename;\n        these are expected by the CLI backup/restore commands\n    \"\"\"\n\n    dict_data = self.asdict(attributes)\n\n    # add fields that backup/restore expects\n    dict_data.update(\n        {\n            \"_version\": __version__,\n            \"_filepath\": self._posix_path,\n            \"_filename\": self._fname.name,\n        }\n    )\n\n    for key, value in dict_data.items():\n        if isinstance(value, datetime.datetime):\n            dict_data[key] = value.isoformat()\n        elif isinstance(value, (list, tuple)):\n            if value and isinstance(value[0], datetime.datetime):\n                dict_data[key] = [v.isoformat() for v in value]\n        elif isinstance(value, bytes):\n            dict_data[key] = base64.b64encode(value).decode(\"ascii\")\n\n    return json.dumps(dict_data, indent=indent)\n</code></pre>"}]}